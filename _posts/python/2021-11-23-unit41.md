---
title:  "[python] 코루틴 사용하기"
excerpt: "unit 41"

categories:
  - python

toc: true
toc_sticky: true
toc_label: "코루틴 사용하기"

last_modified_at: 2021-11-23
---

## 코루틴에 값 보내기

여태는 함수를 호출한 뒤 함수가 끝나면 현재 코드로 다시 돌아왔다.<br>
예를 들어서, 아래처럼 calc 안에서 add를 호출하면, add가 끝나면<br>
add에 들어있던 변수와 계산식이 모두 사라지고 calc 함수로 돌아오게 된다.
```python
def add(a, b):
    c = a + b    # add 함수가 끝나면 변수와 계산식은 사라짐
    print(c)
    print('add 함수')

def calc():
    add(1, 2)    # add 함수가 끝나면 다시 calc 함수로 돌아옴
    print('calc 함수')

calc()  # 3
        # add 함수
        # calc 함수
```

위 코드에서 calc가 메인 루틴이라면 add는 서브 루틴이다.<br>
동작 방식을 그림으로 나타내면 아래와 같다.

<img src = "/assets/images/python/unit41_01_subroutine.jpg" width = "60%" height = "60%">

메인 루틴에서 서브 루틴을 호출하면 서브 루틴의 코드를 실행한 뒤<br>
서브 루틴의 내용을 모두 없애고 메인 루틴으로 돌아온다.<br>
즉, 서브 루틴은 메인 루틴에 종속된 관계라고 볼 수 있다.

하지만 코루틴(coroutine)은 그 방식이 조금 다른데,<br>
메인 루틴과 서브 루틴처럼 어느 한 쪽이 종속된 관계가 아니라<br>
서로 대등한 관계이며 특정 시점에 각각의 코드를 실행한다.<br>
그 동작 방식을 그림으로 나타낸다면 아래와 같다.

<img src = "/assets/images/python/unit41_01_coroutine.jpg" width = "60%" height = "60%">

이처럼 코루틴은 함수가 종료되지 않은 상태에서 메인 루틴의 코드를 실행한 후<br>
다시 돌아와서 코루틴의 코드를 실행한다.<br>
코루틴 함수는 종료된 것이 아니므로 코루틴의 내용도 계속 유지된다.<br>
일반 함수를 호출하면 코드를 한 번만 실행할 수 있지만, 코루틴은 여러번 실행할 수 있다.

코루틴은 제너레이터의 특별한 형태이다.<br>
제너레이터는 yield로 값을 발생시켰지만, 코루틴은 yield로 값을 받아올 수 있다.<br>
아래와 같이 코루틴에 값을 보내면서 코드를 실행할 때는<br>
`코루틴객체.send(값)` 형태로 코드를 실행해주고,<br>
send된 값을 코루틴에서 받으려면<br>
`변수 = (yield)` 로 받아올 수 있다.<br>
아래 예제 코드를 보자.
```python
def number_coroutine():
    while True:  # 코루틴을 계속 유지하기 위해 무한 루프 사용
        x = (yield)
        print(x)

co = number_coroutine()
next(co)  # 코루틴 안의 yield까지 코드 실행(최초 실행), 코루틴은 yield에서 대기
            # co.send(None) 으로도 가능하다.
co.send(1)  # 1
co.send(2)  # 2
co.send(3)  # 3

```